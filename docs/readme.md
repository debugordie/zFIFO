# zfifo driver

## はじめに

zfifoドライバは、XilinxのZynq/ZynqMP SoC上で動作するLinuxから、PL
(FPGA)上のAXI DMAを簡単に利用するためのデバイスドライバです。類似のド
ライバやツールとしては、

- umabuf (https://github.com/ikwzm/udmabuf/)
- xilinx_axidma (https://github.com/bperez77/xilinx_axidma/)

などがすでに広く使われていますが、これらはいずれも専用のDMAバッファを
固定的にメモリ上に確保する必要があります。しかし、実際のアプリケーショ
ンではDMAで送受信したいデータが何らかのライブラリのデータ構造の中にあっ
たりして、なにかと自由が効きませんし、そのようなデータ構造の場合、物理
アドレス空間での連続性も保証されません。

zfifoでは、DMA送受信を行う際に専用のバッファを用いずに、ユーザ空間のデー
タを直接DMA転送するため、メモリ上の任意のデータをDMAで取り扱うことが可
能です。これは柔軟性の面で大きなメリットをもたらしますが、転送前後にいっ
たん対象領域の物理アドレスを固定し、キャッシュをフラッシュする操作が行
われるため、その分のオーバーヘッドが発生します。このオーバーヘッドは特
にCPUがあまり高速でないZynq-7000 SoC環境では転送速度に大きく影響すうる
ので、注意が必要です。

## 動作環境

zfifoは以下の環境で動作します(動作を確認しています)

- ソフトウェア
- Linux kernel: 4.19.0 (Xilinx repository, v2019.1)
- クロスコンパイル用ツールチェーン: Vivado 2019.1付属のもの
- ハードウェア
- Zynq PS / Zynq MPSoC PS
- AXI DMA (Scatter & Gather mode, シングルチャネル構成)

Linuxカーネルのバージョンが異なっても動作するはずですが、DMA関係のAPI
はバージョンによって細かな変更が入る場合があるので、特に4.15.0以前では
パッチが必要な場合があります (古いバージョンで使うことはあまりないかな、
と思って対策していないのですが、難しくはないので、パッチが必要な場合は
ご連絡ください。)

## ドライバのビルドとインストール

### ドライバのビルド

ドライバのビルドに先立ってLinuxカーネルをビルドし、そのソースツリーを
使ってドライバをビルドする必要があります。SoC 上で zfifo ドライバを動
作させるには原則として、これで作ったカーネルとドライバをセットで使用す
る必要があります。また、Vivado に付属する ARM/ARM64 用のコンパイラツー
ルチェーンが必要です。

Linux カーネルのソースツリーの場所を /path/to/kernel/tree とすると、

% make ARCH=arm64 KERNEL_SRC_DIR=/path/to/kernel/tree

のようにすればドライバの zfifo.ko をビルドすることができます
(Zynq-7000の場合は、ARCH=arm とします。) そのほかのファイルはドライバ
の動作にはとりあえず必要ないので、zfifo.ko だけを SoC 上の Linux ファ
イルシステムにコピーしてください。

あるいは、コンパイル済みのカーネルおよびドライバを配布予定なので、そち
らをご利用いただくことも可能です。

### インストール

ドライバをロードするには、

% make insmod zfifo.ko zfifo0=0xa0000000

のようにします。ここで、0xa0000000 は、AXI DMA コントローラのレジスタ
のアドレスですので、適宜読み替えてください。複数の AXI DMA コントロー
ラがある場合、続けて zfifo1 や zfifo2 を指定することも (たぶん) 可能で
す。デバイスツリーによるアドレスの指定にはいまのところ対応していません。

正しくロードされた場合、/dev/zfifo0 が作られて、dmesg に

[ 3214.412466] MM2S_DMASR: 0x10009
[ 3214.412469] S2MM_DMASR: 0x10009

のようなメッセージが残るはずです。MM2S/S2MM DMASR の値が 0x10009 でな
い場合、レジスタアドレスの指定が間違っているか、AXI DMA コアが正しく設
定されていない可能性があります。

/dev/zfifo0 のアクセス権限は適宜修正しても OK ですし、udev の設定など
で自動的に所望の owner/mode にすることも可能と思います。

## 送受信のためのAPI

送受信は /dev/zfifo0 に対する ioctl によって行われますが、ioctl を直接
操作するとあまりプログラムがきれいでないので、libzfifo.c に簡単な
wrapper API を用意しています。ドライバのビルド時に生成される
libzfifo.so を使ってもよいですし、小さなコードなので、自分のコードと一
緒に静的にコンパイルしてしまってもよいでしょう。

libzfifo.c を使う例題として、libzfifo-test.c が一緒に配布されています。
この例題は FIFO でループバック接続された AXI DMA を使ってメモリ上のデー
タをコピーするものですので、おなじく例題として配布されている SoC デザ
イン (後述) をそのまま動かすことが可能です。

### デバイスのオープン・クローズ

zfifo ドライバを使うにはまず /dev/zfifo0 をオープンし、利用が終了したら
クローズします。これは、普通のUnix な open() と close() を利用します。

### DMA送受信

PS から PL にデータを送るには zf_send() を、受け取るには zf_recv() を、
それぞれ使います。引数は以下のようになっています。

    zf_send(fd, (char*)buf, bytes_to_send);
    zf_recv(fd, (char*)buf, bytes_to_recv);

fd は open() で返ってきたファイルディスクリプタ、buf は送受信するデー
タへのポインタで、送受信サイズはバイト数単位で指定します。バッファが
32bit/64bit境界にアラインされていなかったり、送受信バイト数が4あるいは
8の倍数になっていないと、思わぬ不幸が起きる可能性があるかもしれません
(ただし、ふつうに配列として宣言したり、malloc()した領域は32bitあるいは
64bitの境界にアラインされるはずです。)

## SoCを動かす

